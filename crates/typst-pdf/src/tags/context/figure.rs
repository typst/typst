use krilla::tagging::TagKind;
use krilla::tagging::{self as kt, Tag};
use typst_library::foundations::Packed;
use typst_library::model::FigureElem;

use crate::tags::context::FigureId;
use crate::tags::groups::{GroupId, GroupKind};
use crate::tags::resolve::TagNode;
use crate::tags::tree::Tree;
use crate::tags::util::PropertyOptRef;

#[derive(Debug, Clone, PartialEq)]
pub struct FigureCtx {
    pub elem: Packed<FigureElem>,
    pub caption: Option<GroupId>,
    pub tag_kind: FigureTagKind,
}

/// Which tag should be used to represent this figure in the PDF tag tree.
///
/// There is a fundamental mismatch between typst figures and PDF figures.
/// In typst a figure is used to group some illustrative content, optionally give
/// it a caption, and often reference it by labelling it.
/// In PDF a figure is more comparable to an image, and in PDF/UA it *must* have
/// an alternative description. This alternative description *must* describe the
/// entire enclosed content and any AT will not attempt to interpret any content
/// within that tag. This makes the `Figure` tag completely unsuited for figures
/// that contain tables or other structured data.
#[derive(Debug, Default, Clone, Eq, PartialEq)]
pub enum FigureTagKind {
    /// Use a `Figure` tag.
    Figure,
    /// Use a `Div` tag.
    #[default]
    Div,
    /// Don't use any tag.
    None,
}

impl FigureCtx {
    pub fn new(elem: Packed<FigureElem>) -> Self {
        Self {
            elem,
            caption: None,
            tag_kind: FigureTagKind::default(),
        }
    }

    pub fn build_tag(&self) -> Option<TagKind> {
        let alt = self.elem.alt.opt_ref().map(Into::into);
        Some(match self.tag_kind {
            FigureTagKind::Figure => {
                Tag::Figure(alt).with_placement(Some(kt::Placement::Block)).into()
            }
            FigureTagKind::Div => Tag::Div
                .with_alt_text(alt)
                .with_placement(Some(kt::Placement::Block))
                .into(),
            FigureTagKind::None => return None,
        })
    }
}

pub fn build_figure(
    tree: &mut Tree,
    figure_id: FigureId,
    mut parent: GroupId,
    figure: GroupId,
) {
    let figure_ctx = tree.ctx.figures.get_mut(figure_id);
    let group = tree.groups.get(figure);

    if figure_ctx.elem.alt.opt_ref().is_some() {
        // If a figure has an alternative description, always use the
        // figure tag.
        figure_ctx.tag_kind = FigureTagKind::Figure;
    } else if let &[TagNode::Group(child)] = group.nodes() {
        match &tree.groups.get(child).kind {
            GroupKind::Table(..) => {
                // Remove the table from this figure.
                let table = child;
                tree.groups.get_mut(figure).pop_node();

                // Move the caption inside the table.
                if let Some(caption) = figure_ctx.caption {
                    tree.groups.get_mut(caption).parent = table;
                    tree.groups.prepend_group(table, caption);
                }

                // Omit the figure tag and push the table directly into
                // the parent.
                tree.groups.get_mut(table).parent = parent;
                tree.groups.push_group(parent, table);
                return;
            }
            GroupKind::Image(..) => {
                // Use the figure tag generated by the image itself.
                figure_ctx.tag_kind = FigureTagKind::None;
            }
            GroupKind::Formula(..) => {
                // Use the formula tag, which can also serve as an illustation.
                figure_ctx.tag_kind = FigureTagKind::None;
            }
            _ => (),
        }
    } else if group.nodes().iter().any(|n| matches!(n, TagNode::Group(_))) {
        // The figure contains only marked content.
        figure_ctx.tag_kind = FigureTagKind::Figure;
    }

    // If the figure has a caption wrap the caption and the figures in
    // an enclosing element.
    if let Some(caption) = figure_ctx.caption {
        parent = tree.groups.push_tag(parent, Tag::Div);
        tree.groups.get_mut(caption).parent = parent;
        tree.groups.push_group(parent, caption);
    }

    tree.groups.push_group(parent, figure);
}
