# Citation-in-Footnote Failure: Deep Technical Analysis

**Date:** 2026-01-15
**Context:** Phase 1 of wrap-float implementation
**Symptom:** Two tests fail with "cannot format citation in isolation"
- `issue-1597-cite-footnote`
- `issue-3481-cite-location`

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [The Failing Tests](#the-failing-tests)
3. [How Citations Work in Typst](#how-citations-work-in-typst)
4. [The Introspection System](#the-introspection-system)
5. [The Locator System](#the-locator-system)
6. [How Memoization Fits In](#how-memoization-fits-in)
7. [The Phase 1 Changes](#the-phase-1-changes)
8. [Detailed Trace of the Bug](#detailed-trace-of-the-bug)
9. [Why Memoization Was the Original Solution](#why-memoization-was-the-original-solution)
10. [The Proposed Fix](#the-proposed-fix)
11. [Open Questions and Deeper Issues](#open-questions-and-deeper-issues)
12. [Appendix: Key Code Locations](#appendix-key-code-locations)

---

## Executive Summary

Phase 1 changed paragraph layout from **immediate** (at collection time) to **deferred** (at distribution time). This change moved the `realize(LayoutPar)` call from inside a memoized function (`layout_par_impl`) to a non-memoized function (`measure_par_with_exclusions`).

The consequence: `CiteGroup` elements are now created fresh on each layout attempt rather than being cached. When a footnote doesn't fit and is re-laid out, the citation's location may not match what the introspection system expects, causing lookup failures.

---

## The Failing Tests

### Test 1: `issue-1597-cite-footnote` (tests/suite/model/cite.typ:76)

```typst
#set page(height: 60pt)
A

#footnote[@netwok]
#show bibliography: none
#bibliography("/assets/bib/works.bib")
```

**What it tests:** A citation inside a footnote where the footnote might need to migrate to maintain the invariant that footnote markers and entries are on the same page.

### Test 2: `issue-3481-cite-location` (tests/suite/model/cite.typ:95)

```typst
#set page(height: 60pt)

#v(10pt)

#footnote[@netwok \ A]

#show bibliography: none
#bibliography("/assets/bib/works.bib")
```

**What it tests:** Similar scenario with additional content in the footnote, testing locator stability when content moves.

### The Error

```
Error [paged]: cannot format citation in isolation
Hint: check whether this citation is measured without being inserted into the document
```

This error comes from `crates/typst-library/src/model/cite.rs:178`.

---

## How Citations Work in Typst

### Citation Elements

1. **`CiteElem`** - A single citation reference (e.g., `@netwok`)
2. **`CiteGroup`** - A group of adjacent citations, created during realization
3. **`BibliographyElem`** - The bibliography definition

### The Citation Rendering Flow

When a `CiteGroup` needs to be rendered:

```rust
// In crates/typst-library/src/model/cite.rs
impl Packed<CiteGroup> {
    pub fn realize(&self, engine: &mut Engine) -> SourceResult<Content> {
        let location = self.location().unwrap();  // Get THIS element's location
        let span = self.span();
        Works::generate(engine, span)?            // Generate/retrieve cached Works
            .citations
            .get(&location)                       // Look up by location
            .cloned()
            .ok_or_else(failed_to_format_citation)
            .at(span)?
    }
}
```

**Key insight:** The citation is looked up by its `Location`. If the location doesn't exist in the pre-computed `Works.citations` map, the lookup fails.

### The `Works` Structure

`Works` is generated by `Works::generate_impl` (memoized):

```rust
// In crates/typst-library/src/model/bibliography.rs
pub fn generate(engine: &mut Engine, span: Span) -> SourceResult<Arc<Works>> {
    let bibliography = BibliographyElem::find(engine, span).at(span)?;
    let groups = engine.introspect(CiteGroupIntrospection(span));  // Query introspector!
    Self::generate_impl(engine.routines, engine.world, bibliography, groups).at(span)
}

#[comemo::memoize]
fn generate_impl(..., groups: EcoVec<Content>) -> StrResult<Arc<Works>> {
    // Pre-formats all citations, stores them keyed by Location
}
```

**Key insight:** `Works::generate_impl` queries the **introspector** for `CiteGroup` elements. The introspector contains elements from **previous** layout passes.

---

## The Introspection System

### Overview

Typst uses an iterative layout system with introspection:

1. **Pass 1:** Layout runs, elements are created with locations, introspector is empty
2. **End of Pass 1:** Elements with locations are collected into introspector
3. **Pass 2:** Layout runs, introspection queries return data from Pass 1
4. **End of Pass 2:** Updated elements collected
5. **Continue until stable** (convergence)

### The `Introspector`

The introspector stores elements that have been laid out and allows querying them:

- `engine.introspect(query)` - Run an introspection query
- Elements are identified by their `Location`
- Queries return elements from the **previous** layout pass

### The Convergence Problem

For citations:
- Pass N: `CiteGroup` created with location `L_N`
- End of Pass N: `CiteGroup` at `L_N` stored in introspector
- Pass N+1: `Works::generate_impl` queries introspector, gets `CiteGroup` at `L_N`
- Pass N+1: When rendering, `CiteGroup` must have location `L_N` to match

**If `L_N` ≠ `L_N+1`, the lookup fails.**

---

## The Locator System

### Purpose

Locators generate unique, stable `Location` values for elements. Location stability is critical for:
- Introspection queries
- Cross-references
- Citation lookups
- Counter resolution

### Key Types

```rust
// In crates/typst-library/src/introspection/locator.rs

/// A locator that can generate locations for child elements.
pub struct Locator<'a> {
    local: u128,                    // Local hash component
    outer: Option<&'a LocatorLink<'a>>,  // Link to outer memoization boundary
}

/// Generates unique sublocators for multiple children.
pub struct SplitLocator<'a> {
    local: u128,
    outer: Option<&'a LocatorLink<'a>>,
    disambiguators: FxHashMap<u128, usize>,  // Counts calls with same key
}

/// The resolved value of a locator.
enum Resolved {
    Hash(u128),                     // Normal: location from hash
    Measure(Location, Span),        // Measurement mode: query introspector
}
```

### Key Operations

#### `Locator::synthesize(location)`
Creates a locator from an existing location's hash. Used for dependent layouts (e.g., footnote entries based on footnote elements).

```rust
pub fn synthesize(location: Location) -> Self {
    Self { local: location.hash(), outer: None }
}
```

#### `Locator::relayout()`
Creates a copy of the locator for re-layout. The copy has the same `local` and `outer`, ensuring the same location chain.

```rust
pub fn relayout(&self) -> Self {
    Self { local: self.local, outer: self.outer }
}
```

#### `SplitLocator::next(key)`
Generates a sub-locator for a child element:

```rust
pub fn next_inner(&mut self, key: u128) -> Locator<'a> {
    // Get/increment disambiguator for this key
    let disambiguator = {
        let slot = self.disambiguators.entry(key).or_default();
        std::mem::replace(slot, *slot + 1)
    };

    // Combine into new local hash
    let local = typst_utils::hash128(&(key, disambiguator, self.local));

    Locator { outer: self.outer, local }
}
```

#### `SplitLocator::next_location(engine, key, span)`
Generates a `Location` for an element:

```rust
pub fn next_location(&mut self, engine: &mut Engine, key: u128, elem_span: Span) -> Location {
    match self.next_inner(key).resolve() {
        Resolved::Hash(hash) => Location::new(hash),
        Resolved::Measure(anchor, measure_span) => {
            // Query introspector to find matching element
            engine.introspect(MeasureIntrospection { key, anchor, elem_span, measure_span })
                .unwrap_or(anchor)
        }
    }
}
```

### Location Stability

For a `CiteGroup` to have a stable location across passes:

1. The locator chain must be identical
2. The `key` (element hash) must be identical
3. The `disambiguator` must be identical (same processing order)
4. Any outer links must resolve to the same values

---

## How Memoization Fits In

### The `#[comemo::memoize]` Attribute

Comemo is Typst's memoization system. Functions marked with `#[comemo::memoize]`:
- Cache results based on input hash
- Return cached results for identical inputs
- Use `Tracked<T>` types for inputs that should be part of the cache key

### Memoized Layout Functions

Several layout functions are memoized:

```rust
// layout_par_impl - paragraph layout (BEFORE Phase 1)
#[comemo::memoize]
fn layout_par_impl(
    elem: &Packed<ParElem>,
    routines: &Routines,
    world: Tracked<dyn World + '_>,
    introspector: Tracked<Introspector>,
    traced: Tracked<Traced>,
    sink: TrackedMut<Sink>,
    route: Tracked<Route>,
    locator: Tracked<Locator>,  // Locator is TRACKED
    styles: StyleChain,
    region: Size,
    expand: bool,
    situation: ParSituation,
) -> SourceResult<Fragment>

// layout_fragment_impl - fragment layout
#[comemo::memoize]
fn layout_fragment_impl(
    ...,
    locator: Tracked<Locator>,  // Locator is TRACKED
    ...,
    regions: Regions,           // Regions affect cache key
) -> SourceResult<Fragment>
```

### What Memoization Provides

1. **Performance:** Avoid redundant computation
2. **Consistency:** Same inputs → same outputs → same element instances
3. **Location Stability:** Cached results contain elements with stable locations

### The `Tracked<Locator>` Pattern

When a locator is tracked for memoization:

```rust
pub fn layout_par(
    elem: &Packed<ParElem>,
    engine: &mut Engine,
    locator: Locator,
    ...
) -> SourceResult<Fragment> {
    layout_par_impl(
        elem,
        engine.routines,
        engine.world,
        engine.introspector.into_raw(),
        engine.traced,
        TrackedMut::reborrow_mut(&mut engine.sink),
        engine.route.track(),
        locator.track(),  // TRACK the locator for memoization
        ...
    )
}
```

Inside the memoized function:

```rust
fn layout_par_impl(
    ...,
    locator: Tracked<Locator>,
    ...
) -> SourceResult<Fragment> {
    let introspector = Protected::from_raw(introspector);
    let link = LocatorLink::new(locator);           // Create link from tracked locator
    let mut locator = Locator::link(&link).split(); // Create split locator
    let mut engine = Engine { ... };                // Reconstruct engine

    // Now realize and layout...
}
```

---

## The Phase 1 Changes

### Before Phase 1: Immediate Paragraph Layout

```
layout_fragment_impl (memoized)
└── realize(LayoutFragment) → creates ParElem
└── layout_flow
    └── collect
        └── layout_par (calls layout_par_impl, MEMOIZED)
            └── realize(LayoutPar) → creates CiteGroup with location
            └── linebreak, finalize → frames
        └── stores LineChild (pre-laid-out frames)
    └── distribute → places frames
```

**Key point:** `realize(LayoutPar)` happens inside memoized `layout_par_impl`. The `CiteGroup` instances are part of the cached result.

### After Phase 1: Deferred Paragraph Layout

```
layout_fragment_impl (memoized)
└── realize(LayoutFragment) → creates ParElem
└── layout_flow
    └── collect
        └── stores ParChild (deferred, NOT laid out yet)
    └── distribute
        └── par.measure() → measure_par_with_exclusions (NOT memoized)
            └── realize(LayoutPar) → creates CiteGroup with location
            └── linebreak → metrics only
        └── par.commit() → commit_par (NOT memoized)
            └── realize(LayoutPar) → creates CiteGroup AGAIN
            └── finalize → frames
```

**Key point:** `realize(LayoutPar)` now happens in non-memoized functions. `CiteGroup` instances are created fresh each time.

### The Critical Difference

| Aspect | Before Phase 1 | After Phase 1 |
|--------|---------------|---------------|
| Where `realize(LayoutPar)` happens | Inside memoized `layout_par_impl` | Inside non-memoized `measure_par_with_exclusions` |
| `CiteGroup` instances | Cached, reused | Created fresh each call |
| Location stability | Guaranteed by memoization | Depends on locator chain being identical |

---

## Detailed Trace of the Bug

### Setup

Test: `issue-1597-cite-footnote`
```typst
#set page(height: 60pt)
A
#footnote[@netwok]
```

### Pass 1 (Initial Layout)

#### Step 1: Document Realization

The document is realized at the top level. This creates:
- Text "A"
- `FootnoteElem` containing `CiteElem` (@netwok)

The `FootnoteElem` gets a location (let's call it `L_fn`) via the document's locator.

#### Step 2: Page Layout

The page is laid out:
- "A" is placed
- Footnote marker is placed
- Footnote entry needs to be laid out

#### Step 3: Footnote Layout

```rust
// In compose.rs
fn layout_footnote(engine, config, elem, pod) -> SourceResult<Fragment> {
    let loc = elem.location().unwrap();  // L_fn
    crate::layout_fragment(
        engine,
        &FootnoteEntry::new(elem.clone()).pack().spanned(elem.span()).located(loc.variant(1)),
        Locator::synthesize(loc),  // Synthesize locator from L_fn
        config.shared,
        pod,  // Available regions
    )
}
```

#### Step 4: Inside `layout_fragment_impl` (First Call)

```rust
// Memoized, first call with these inputs
fn layout_fragment_impl(..., locator: Tracked<Locator>, ..., regions: Regions) {
    let link = LocatorLink::new(locator);
    let mut locator = Locator::link(&link).split();

    // Realize footnote content
    let children = realize(LayoutFragment, &mut locator, ...);
    // children contains ParElem wrapping CiteElem

    layout_flow(&mut engine, &children, &mut locator, ..., regions)
}
```

#### Step 5: Inside `layout_flow`

```rust
fn layout_flow(engine, children, locator, ..., regions) {
    let children = collect(engine, ..., locator.next(&()), ...)?;
    // children now contains ParChild (Phase 1 change)

    // Distribution loop
    compose(engine, &mut work, ...)
}
```

#### Step 6: Inside `collect` → `par()`

```rust
fn par(&mut self, elem: &Packed<ParElem>, styles: StyleChain) {
    let locator = self.locator.next(&elem.span());  // Derive locator for paragraph

    let par_child = ParChild {
        elem,
        styles,
        locator,  // Captured!
        ...
    };
    self.output.push(Child::Par(self.boxed(par_child)));
}
```

#### Step 7: Distribution → `par.measure()`

```rust
// In distribute.rs
fn par(&mut self, par: &ParChild) -> FlowResult<()> {
    let measured = par.measure(self.composer.engine)?;
    let result = par.commit(self.composer.engine, &measured)?;
    ...
}
```

#### Step 8: Inside `measure_par_with_exclusions` (NOT memoized)

```rust
pub fn measure_par_with_exclusions(
    elem: &Packed<ParElem>,
    engine: &mut Engine,
    locator: Locator,  // From par.locator.relayout()
    ...
) -> SourceResult<ParMeasureResult> {
    let mut split_locator = locator.split();

    // THIS IS WHERE CiteGroup IS CREATED
    let children = (engine.routines.realize)(
        RealizationKind::LayoutPar,
        engine,
        &mut split_locator,
        &arenas,
        &elem.body,  // Paragraph body contains CiteElem
        styles,
    )?;

    // During realize:
    // 1. CiteElem is encountered
    // 2. CITES grouping rule triggers
    // 3. finish_cites creates NEW CiteGroup
    // 4. visit() calls prepare_elem()
    // 5. prepare_elem() calls locator.next_location() → Location L1
    // 6. CiteGroup gets location L1

    measure_par_inner(engine, &children, &mut split_locator, ...)
}
```

#### Step 9: `CiteGroup::realize()` is Called

When the citation needs to render:

```rust
impl Packed<CiteGroup> {
    pub fn realize(&self, engine: &mut Engine) -> SourceResult<Content> {
        let location = self.location().unwrap();  // L1
        Works::generate(engine, span)?
            .citations
            .get(&location)  // Look up L1
            ...
    }
}
```

#### Step 10: `Works::generate_impl` (First Call)

```rust
fn generate(engine: &mut Engine, span: Span) -> SourceResult<Arc<Works>> {
    let groups = engine.introspect(CiteGroupIntrospection(span));
    // In Pass 1, introspector might be empty or have stale data
    Self::generate_impl(..., groups)
}
```

**At this point in Pass 1:** The introspector may not have the current `CiteGroup` yet. This might cause issues, but Typst handles it through convergence.

#### Step 11: Footnote Doesn't Fit

The footnote entry frames are returned. The first frame might be empty (doesn't fit in available space).

```rust
// In compose.rs footnote()
if first.is_empty() && exist_non_empty_frame {
    if migratable && regions.may_progress() {
        return Err(Stop::Finish(false));  // Trigger migration
    } else if regions.may_progress() || !flow_need.is_zero() {
        self.footnote_queue.push(elem);   // Queue for later
        return Ok(());
    }
}
```

#### Step 12: Content Migrates to Page 2

The outer layout system handles the `Stop::Finish` by moving content to the next page.

#### Step 13: Footnote is Laid Out AGAIN

On page 2, `layout_footnote` is called again with:
- Same `elem` (same `FootnoteElem`)
- Same `Locator::synthesize(loc)` (same synthesized locator)
- **Different `pod`** (different available regions on page 2)

#### Step 14: `layout_fragment_impl` Cache Miss

Because `regions` is different, the memoization cache **misses**. The function runs fresh.

#### Step 15: Fresh `realize(LayoutPar)` → New `CiteGroup`

```rust
// In measure_par_with_exclusions (NOT memoized, runs again)
let children = (engine.routines.realize)(
    RealizationKind::LayoutPar,
    engine,
    &mut split_locator,
    &arenas,
    &elem.body,
    styles,
)?;

// A NEW CiteGroup instance is created!
// It gets location L2 from the locator
```

#### Step 16: Location Mismatch?

**The critical question:** Is `L1 == L2`?

If the locator chain is identical:
- Same `Locator::synthesize(loc)` → same starting point
- Same `LocatorLink` creation
- Same `split()` → fresh disambiguators (both start at 0)
- Same `next()` calls in same order
- Same `key` (hash of CiteGroup element)

**Theoretically, `L1` should equal `L2`.**

But the `CiteGroup` **instance** is different. And `Works::generate_impl` may have cached data from a previous state.

#### Step 17: The Lookup

```rust
// CiteGroup::realize()
Works::generate(engine, span)?
    .citations
    .get(&location)  // L2
```

`Works::generate_impl` queries the introspector for `CiteGroup` elements. The introspector has elements from the **previous** layout pass (or earlier in the convergence loop).

**If the `CiteGroup` in the introspector has a different location, the lookup fails.**

---

## Why Memoization Was the Original Solution

### Before Phase 1

`layout_par_impl` was memoized with `locator: Tracked<Locator>` as part of the cache key.

When the footnote was re-laid out:
1. `layout_fragment_impl` cache misses (different regions)
2. It runs fresh, calls `layout_flow` → `collect`
3. `collect` calls `layout_par` for paragraphs
4. `layout_par` calls `layout_par_impl` (MEMOIZED)
5. `layout_par_impl` cache **HITS** because:
   - Same `elem` (same paragraph)
   - Same `locator` (derived from same parent chain)
   - Same other inputs

The **cached result** contains the **same `CiteGroup` instances** with the **same locations**.

### The Memoization Guarantee

Memoization ensures that for identical inputs:
1. The same **element instances** are returned
2. These instances have the **same locations** (set once, cached forever)
3. The introspection system sees **consistent elements** across passes

### What Phase 1 Broke

By moving `realize(LayoutPar)` out of memoized `layout_par_impl` and into non-memoized `measure_par_with_exclusions`:

1. Each call creates **new `CiteGroup` instances**
2. New instances get **new locations** (even if the hash is the same, the instance is different)
3. The introspection system may have **stale references** to old instances

**Wait, that's not quite right either.** Locations are hashes, not instance identifiers. Let me reconsider...

---

## Re-examining the Root Cause

### Locations are Hashes

`Location` is essentially a `u128` hash:

```rust
pub struct Location(u128);

impl Location {
    pub fn new(hash: u128) -> Self {
        Self(hash)
    }

    pub fn hash(&self) -> u128 {
        self.0
    }
}
```

So if the locator produces the same hash, the `Location` is the same, regardless of instance.

### So Why Does the Lookup Fail?

Let me re-examine the `Works::generate_impl` flow:

```rust
fn generate(engine: &mut Engine, span: Span) -> SourceResult<Arc<Works>> {
    let groups = engine.introspect(CiteGroupIntrospection(span));
    Self::generate_impl(..., groups)
}
```

`engine.introspect(CiteGroupIntrospection(span))` returns `CiteGroup` elements from the introspector.

The introspector is populated with elements that have been **tagged** during layout. Tags are created in `prepare_elem`:

```rust
// In realize/lib.rs prepare_elem()
let tags = elem
    .location()
    .map(|loc| (Tag::Start(elem.clone(), flags), Tag::End(loc, key, flags)));
```

These tags are inserted into frames during layout and collected by the introspector at the end of the pass.

### The Timing Issue

Here's where it gets subtle:

1. **Pass N layout begins**
2. Footnote is laid out (first attempt)
3. `realize(LayoutPar)` creates `CiteGroup_A` with location `L`
4. `CiteGroup_A::realize()` is called
5. `Works::generate_impl` queries introspector for `CiteGroup` elements
6. Introspector has data from **Pass N-1**, which might have `CiteGroup_old` with location `L_old`
7. If `L ≠ L_old`, the current `CiteGroup_A` won't be found

**But wait**, `Works::generate_impl` is memoized. Its cache key includes `groups` (the queried `CiteGroup` elements). If the groups are different between calls, the cache misses and it regenerates.

### The Real Issue: Within-Pass Consistency

I think the issue is **within a single pass**, not across passes:

1. Footnote is laid out (first attempt, doesn't fit)
2. `CiteGroup_A` is created with location `L`
3. `CiteGroup_A::realize()` is called
4. `Works::generate_impl` queries introspector → gets empty or stale data
5. `Works` is generated based on that data (might not include `CiteGroup_A`)
6. Lookup for location `L` fails because `Works` doesn't have it

**But this would fail in the original code too...**

### Another Theory: Double Realization

In Phase 1:
1. `measure_par_with_exclusions` calls `realize(LayoutPar)` → creates `CiteGroup_A` with location `L`
2. `commit_par` calls `realize(LayoutPar)` **AGAIN** → creates `CiteGroup_B` with location `L'`

If `L ≠ L'`, there's an inconsistency.

Looking at the code:

```rust
// measure_par_with_exclusions
let children = (engine.routines.realize)(..., &mut split_locator, ...)?;
// split_locator is created from locator.split()

// commit_par
let children = (engine.routines.realize)(..., &mut split_locator, ...)?;
// split_locator is created from locator.split() AGAIN (fresh)
```

Both create fresh `SplitLocator` instances from the same base `Locator`. They should produce the same locations because:
- Same base locator → same `local` and `outer`
- Fresh disambiguators → both start at 0
- Same content → same processing order

**So `L` should equal `L'`.**

### Yet Another Theory: The Introspector Query

`Works::generate_impl` calls `engine.introspect(CiteGroupIntrospection(span))`.

Let's look at `CiteGroupIntrospection`:

```rust
// Likely in bibliography.rs or similar
struct CiteGroupIntrospection(Span);

impl Introspect for CiteGroupIntrospection {
    type Output = EcoVec<Content>;

    fn introspect(&self, engine: &mut Engine, introspector: Tracked<Introspector>) -> Self::Output {
        introspector.query(&CiteGroup::ELEM.select())
        // Returns all CiteGroup elements from the introspector
    }
}
```

The introspector contains elements that have been **laid out and tagged**. But in the current pass, the `CiteGroup` might not be tagged yet!

Here's the sequence:
1. `realize(LayoutPar)` creates `CiteGroup`
2. `CiteGroup::realize()` is called to render it
3. `Works::generate` queries introspector for `CiteGroup` elements
4. But the current `CiteGroup` hasn't been tagged yet (tags are inserted into frames during `finalize`)
5. Introspector returns stale data from previous pass
6. If this is Pass 1 or the location changed, lookup fails

### The Memoization "Fix"

With `layout_par_impl` memoized:
1. First call: `realize(LayoutPar)` → `CiteGroup` → `CiteGroup::realize()` → `Works::generate` (might fail)
2. Typst's convergence loop handles this by re-running
3. Second call to `layout_par_impl`: **Cache HIT**
4. Same `CiteGroup` instance returned
5. By now, introspector has the `CiteGroup` from Pass 1
6. `Works::generate` cache hits with correct data
7. Lookup succeeds

Without memoization:
1. First call: `realize(LayoutPar)` → `CiteGroup_A` → might fail
2. Second call (re-layout): `realize(LayoutPar)` → `CiteGroup_B` (new instance!)
3. Even if locations are the same, the **timing** of when `Works` is queried vs when `CiteGroup` is tagged is different
4. Cache coherence issues arise

---

## The Proposed Fix

### Option 1: Add Memoization to `measure_par_with_exclusions`

Create a memoized wrapper following `layout_par_impl`'s pattern:

```rust
pub fn measure_par_with_exclusions(
    elem: &Packed<ParElem>,
    engine: &mut Engine,
    locator: Locator,
    ...
) -> SourceResult<ParMeasureResult> {
    measure_par_impl(
        elem,
        engine.routines,
        engine.world,
        engine.introspector.into_raw(),
        engine.traced,
        TrackedMut::reborrow_mut(&mut engine.sink),
        engine.route.track(),
        locator.track(),  // Track locator for cache key
        ...
    )
}

#[comemo::memoize]
fn measure_par_impl(
    elem: &Packed<ParElem>,
    routines: &Routines,
    world: Tracked<dyn World + '_>,
    introspector: Tracked<Introspector>,
    traced: Tracked<Traced>,
    sink: TrackedMut<Sink>,
    route: Tracked<Route>,
    locator: Tracked<Locator>,
    ...
) -> SourceResult<ParMeasureResult> {
    // Reconstruct engine and locator chain
    let introspector = Protected::from_raw(introspector);
    let link = LocatorLink::new(locator);
    let mut locator = Locator::link(&link).split();
    let mut engine = Engine { ... };

    // Now realize and measure
    let children = (engine.routines.realize)(...)?;
    measure_par_inner(...)
}
```

**Pros:**
- Restores pre-Phase-1 behavior
- Ensures location stability through caching
- Matches documented design

**Cons:**
- May mask deeper issues
- Adds complexity
- Need to do the same for `commit_par`

### Option 2: Use `layout_par` for Phase 1

Change `ParChild::layout()` to use the existing memoized `layout_par`:

```rust
impl ParChild {
    pub fn layout(&self, engine: &mut Engine) -> SourceResult<ParCommitResult> {
        let fragment = crate::inline::layout_par(
            self.elem,
            engine,
            self.locator.relayout(),
            self.styles,
            self.base,
            self.expand,
            self.situation,
        )?;
        Ok(ParCommitResult { frames: fragment.into_frames() })
    }
}
```

**Pros:**
- Minimal change
- Uses proven, working code
- Immediate fix

**Cons:**
- Doesn't exercise measure/commit split
- Phase 2 will need proper memoization anyway

### Option 3: Investigate Deeper

The real question: **Why does creating fresh `CiteGroup` instances cause lookup failures when the locations should be identical?**

This might reveal:
- A bug in the introspection system
- A timing issue with when elements are tagged
- An assumption that memoization was silently enforcing

---

## Open Questions and Deeper Issues

### Question 1: Are Locations Actually Identical?

My analysis suggests they should be, but I haven't verified empirically. Adding debug logging to confirm:
- `CiteGroup` location in first layout attempt
- `CiteGroup` location in second layout attempt (after migration)
- What `Works::generate` returns
- What location the lookup is searching for

### Question 2: Is the Issue Instance Identity vs Location Hash?

Somewhere in the system, there might be an assumption that the same **instance** (by pointer/reference) will be seen. Memoization ensures this; non-memoized code doesn't.

### Question 3: Why Does `Works::generate_impl` Cache Interact Badly?

`Works::generate_impl` is memoized with `groups: EcoVec<Content>` as part of the cache key. If `groups` changes (different `CiteGroup` instances), the cache misses.

But if the cache misses, it should regenerate with the new groups. Unless the new groups don't have the location being looked up...

### Question 4: Is There a Fundamental Design Issue?

The fact that memoization is required for correctness (not just performance) suggests a potential design issue:
- Should `CiteGroup` locations be determined earlier (during initial realization)?
- Should `Works` be generated differently?
- Should the convergence loop handle this case explicitly?

### Question 5: How Will Phase 2 Work?

Phase 2 needs `measure_par_with_exclusions` to run with **different** exclusions, producing **different** line breaks. If memoization is required for citation correctness, how do we handle:
- Same paragraph, different exclusions → different layout
- Citations should still work

The answer might be that memoization cache key includes exclusions, so different exclusions = different cached result = different `CiteGroup` instances, but each exclusion set is consistent within itself.

---

## Appendix: Key Code Locations

### Citation System
- `crates/typst-library/src/model/cite.rs` - CiteElem, CiteGroup
- `crates/typst-library/src/model/bibliography.rs` - Works, Works::generate_impl

### Introspection System
- `crates/typst-library/src/introspection/locator.rs` - Locator, SplitLocator, Location
- `crates/typst-library/src/introspection/mod.rs` - Introspector, Introspect trait

### Realization System
- `crates/typst-realize/src/lib.rs` - realize(), visit(), prepare_elem(), finish_cites()

### Layout System
- `crates/typst-layout/src/inline/mod.rs` - layout_par, measure_par_with_exclusions, commit_par
- `crates/typst-layout/src/flow/collect.rs` - collect(), ParChild
- `crates/typst-layout/src/flow/distribute.rs` - Distributor::par()
- `crates/typst-layout/src/flow/compose.rs` - layout_footnote()
- `crates/typst-layout/src/flow/mod.rs` - layout_fragment, layout_fragment_impl

### Memoization
- Uses `comemo` crate
- `#[comemo::memoize]` attribute
- `Tracked<T>` for cache key inputs
- `TrackedMut<T>` for mutable state that affects caching

---

## Conclusion

The citation-in-footnote failure is caused by Phase 1's change to paragraph layout timing. Moving `realize(LayoutPar)` from memoized `layout_par_impl` to non-memoized `measure_par_with_exclusions` breaks the assumption that citation elements have stable identities across layout attempts.

The recommended fix is to add memoization to the new functions, matching the pattern of `layout_par_impl`. However, deeper investigation into why fresh instances with identical locations cause failures could reveal important insights about the introspection system's assumptions.
